// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
//
:projectid: microprofile-reactive-messaging-rest
:page-layout: guide-multipane
:page-duration: 25 minutes
:page-releasedate: 2020-04-22
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to send and receive messages in reactive Java microservices using a RESTful endpoint
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE']
:page-related-guides: ['reactive-service-testing', 'microprofile-reactive-messaging']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Sending and receiving messages by using a RESTful endpoint in reactive Java microservices
:page-seo-description: A reactive programming tutorial with examples on how to send and receive messages using a RESTful endpoint using MicroProfile Reactive Messaging and Apache Kafka.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Sending and receiving events in RESTful microservices

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to trigger messages in reactive Java microservices via RESTful endpoints.

== What you'll learn

You will learn how to use a RESTful endpoint to trigger reactive microservices to produce and send messages to other microservices
using MicroProfile Reactive Messaging. The current implementation of MicroProfile Reactive Messaging operates on continuous
streams of events. For instance, Producer produces events periodically, and Consumer consumes those events. You will
write microservices so that when a user hits the RESTful endpoint, producer events are generated.
You will learn how to bridge the gap between reactive applications and RESTful ones by using RxJava. You will also learn how we
can achieve code execution on demand in reactive applications.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads.
The current inventory of systems can be accessed via the `/systems` REST endpoint. You will update the `inventory`
microservice to also subscribe to a `PUT` request response that queries a specific system property on the `system`
microservice. You will configure new channels to handle the messages sent and received by the new endpoint.
You can learn more about how the reactive Java services used in this guide works by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.
Please refer to the figure below for a diagram of the application used in this guide.

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory,align="center"]


== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official
https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers.
An installation of Apache Kafka is provided in another Docker container.


[role='command']
include::{common-includes}/gitclone.adoc[]


== Creating the inventory microservice

//file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

Navigate to the `start` directory to begin.

The included `inventory` microservice records and stores the average system load information from all of the connected
system microservices, it does not contain a hittable REST endpoint to control the sending or receiving of reactive messages.
Add the RESTful endpoint to the `inventory` service by creating the `InventoryResource` class.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

The changes include creating the [hotspot=updateSystemProperty file=0]`updateSystemProperty()` method which creates the
[hotspot=putPath file=0]`/data` endpoint that accepts `PUT` requests with a system property name in the request body.

RxJava is used to bridge the current gap between the imperative RESTful endpoint method and the reactive asynchronous
programming that exists by default. RxJava introduces the concepts of an observable and an observer, which decouples
the request that a Java bean will make from the response that it receives. These concepts in addition with MicroProfile
Reactive Messaging creates a fully reactive application.

When the `inventory` service receives a request, it adds the system property name from the request body to the
[hotspot=flowableEmitter file=0]`propertyNameEmitter` [hotspot=flowableEmitterDecl file=0]`FlowableEmitter`.
The [hotspot=flowableCreate file=0]`Flowable.create()` RxJava method is used to create a Publisher and an associated emitter.
The property name sent to the emitter will be sent to the Publisher. The Publisher is returned from the
[hotspot=OutgoingPropertyName file=0]`@Outgoing("requestSystemProperty")` channel, which you will configure later in the
guide. MicroProfile Reactive Messaging takes care of assigning the Publisher to the channel.

== Creating the system microservice

//file 0
SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The `system` microservice is the producer of the messages that are published to the Kafka messaging system as a stream of
events. Every 15 seconds, the `system` microservice publishes events that contain its calculation of the average system
load (its CPU usage) for the last minute. Replace the `SystemService` class to add the message processing of the specific
system property request from the `inventory` microservice and publish it to the Kafka messaging system.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

The changes include creating a method named [hotspot=sendProperty file=0]`sendProperty()` which receives a
system property name from the `inventory` microservice over the [hotspot=propertyRequest file=0]`@Incoming("propertyRequest")`
channel, calculates the requested property on the fly and publishes it back to Kafka over the
[hotspot=propertyResponse file=0]`@Outgoing("propertyResponse")` channel. The [hotspot=sendProperty file=0]`sendProperty()`
method acts as a processor in this scenario. Similar to the `inventory` microservice, the two channels will be configured
next.

== Configuring the MicroProfile Reactive Messaging connectors for Kafka

//file 0
inventory/microprofile-config.properties
[source, text, linenums, role='code_column']
----
include::finish/inventory/src/main/resources/META-INF/microprofile-config.properties[]
----

//file 1
system/microprofile-config.properties
[source, text, linenums, role='code_column']
----
include::finish/system/src/main/resources/META-INF/microprofile-config.properties[]
----

The `system` and `inventory` services exchange messages with the external messaging system through a channel. The
MicroProfile Reactive Messaging Connector API makes it easy to connect each service to the channel. You just need to add
configuration keys in a properties file for each of the services. These configuration keys define properties such as the
name of the channel and the topic in the Kafka messaging system. Open Liberty includes the `liberty-kafka` connector for
sending and receiving messages from Apache Kafka.

The system and inventory microservices each have a MicroProfile Config property file to define the properties of their
incoming and outgoing streams. They are missing the four required channels to complete the message loop created in the
previous sections.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the inventory/microprofile-config.properties file.#
`inventory/src/main/resources/META-INF/microprofile-config.properties`
----

The newly created RESTful endpoint requires new channels to be created to move the requested messages between the `system`
and `inventory` microservices. Replacing the `inventory` microservice [hotspot file=1]`microprofile-config.properties`
file adds the two channels,
[hotspot=requestSystemProperty file=1]`requestSystemProperty` and [hotspot=addSystemProperty file=1]`addSystemProperty`
to handle sending the system property request, and receiving the system property response respectively.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the system/microprofile-config.properties file.#
`system/src/main/resources/META-INF/microprofile-config.properties`
----

Replace the `system` microservice [hotspot file=0]`microprofile-config.properties` file to add the two new
[hotspot=propertyRequest file=0]`propertyRequest` and [hotspot=propertyResponse file=0]`propertyResponse`
channels to handle receiving the property request, and sending the property response respectively.

NOTE : If you want the message to be sent to all the `System` microservices then configure the unique
[hotspot=group4 file=0]`group.id` for all of the instances.

== Building and running the application

Build the `system` and `inventory` microservices using Maven and then run them in Docker containers.

Start your Docker environment. Dockerfiles are provided for you to use.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the
containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and the microservices in the
project. For simplicity, the script starts one instance of the `system` service.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

Wait for the services to become available. After the services are up and running, you can access the
application by making a GET request to the `/systems` endpoint of the `inventory` service.

Visit the http://localhost:9085/inventory/systems[^] URL to access the inventory microservice. You see the CPU `systemLoad`
property for all the systems:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",   
   "systemLoad":1.44
}
----

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU `systemLoad`
property for the systems changed.

Make a `PUT` request on the `\http://localhost:9085/inventory/data` URL to add the value of a particular system
property to the set of existing properties.

For example :

The `PUT` request with the `os.name` system property in the request body on the `\http://localhost:9085/inventory/data`
URL will add the `os.name` system property for your system.

Make a `PUT` request to the service by using `curl`:

[role=command]
```
curl -X PUT -d "os.name" http://localhost:9085/inventory/data --header "Content-Type:text/plain"
```

If the `curl` command is unavailable, then use https://www.getpostman.com/[Postman^]. Postman enables you
to make requests using a graphical interface. To make a request with Postman, enter `\http://localhost:9085/inventory/systems`
into the URL bar and change the request from `GET` to `PUT`. Go to the `Body` tab and enter the `os.name` value under
raw category. Click the blue `Send` button to make the request.

You see the following output:

[source, role="no_copy"]
----
Request successful for the os.name property
----

Since the `system` service is available, the request to the service is successful and returns a `200` response code.

You can revisit the http://localhost:9085/inventory/systems[^] URL and see the `os.name` system property value in addition
to the previous values:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "os.name":"Linux",
   "systemLoad":1.44
}
----

== Tearing down the environment

Run the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You just developed a reactive Java application using MicroProfile Reactive Messaging, Open Liberty, and Kafka.

include::{common-includes}/attribution.adoc[subs="attributes"]