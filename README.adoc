// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
//
:projectid: microprofile-reactive-messaging-rest
:page-layout: guide-multipane
:page-duration: 25 minutes
:page-releasedate: 2020-04-22
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to send and receive messages in reactive Java microservices using a RESTful endpoint
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE']
:page-related-guides: ['reactive-service-testing', 'microprofile-reactive-messaging']
:page-permalink: /guides/{projectid}
:imagesdir: /img/guide/{projectid}
:page-seo-title: Sending and receiving messages by using a RESTful endpoint in reactive Java microservices
:page-seo-description: A reactive programming tutorial with examples on how to send and receive messages using a RESTful endpoint using MicroProfile Reactive Messaging and Apache Kafka.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/dev
:source-highlighter: prettify
= Sending and receiving events in RESTful microservices

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].   

Learn how to trigger messages in reactive Java microservices via RESTful endpoints.

== What you'll learn

You will learn how to use a RESTful endpoint to trigger reactive microservices to produce and send messages to other microservices
using MicroProfile Reactive Messaging. The current implementation of MicroProfile Reactive Messaging operates on continuous
streams of events. For instance, Producer produces events periodically, and Consumer consumes those events. This guide
helps you write microservices so that when a user hits the RESTful endpoint, producer events are generated.  Most importantly,
you'll learn how to bridge the gap between reactive applications and RESTful ones. You'll also learn how we can achieve code
execution on demand in reactive applications.

The reactive application in this guide sends and receives messages between services using an external message broker,
https://kafka.apache.org/[Apache Kafka^]. Using an external message broker enables asynchronous communications between
services so that requests are non-blocking and decoupled from responses.  Before
you go any further, it is highly recommended to go through the basic guide.

In order to build an asynchronous application, RxJava is used to bridge the gap between the standard imperative
and the reactive asynchronous programming. RxJava introduces the concepts of an observable and an observer, which decouples
the request that a Java bean will make from the response that it receives. These concepts in addition with Microprofile
Reactive Messaging create a fully reactive application.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads. The
`inventory` microservice also subscribes to a `PUT` request response that queries a specific system property on the `system`
microservice. The current inventory of systems can be accessed via the `/systems` REST endpoint. You'll create the `system`
and `inventory` microservices using MicroProfile Reactive Messaging. You can learn more about how the reactive Java services
used in this guide works by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.
Please refer to the figure below for a diagram of the application used in this guide.

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory,align="center"]


== Additional prerequisites

You need to have Docker installed. For installation instructions, refer to the official
https://docs.docker.com/get-docker/[Docker documentation^]. You will build and run the microservices in Docker containers.
An installation of Apache Kafka is provided in another Docker container.


[role='command']
include::{common-includes}/gitclone.adoc[]


== Creating the inventory microservice

//file 0
InventoryResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[]
----

//file 1
inventory/microprofile-config.properties
[source, Text, linenums, role='code_column hide_tags=copyright']
----
include::finish/inventory/src/main/resources/META-INF/microprofile-config.properties[]
----

Navigate to the `start` directory to begin.

The `inventory` microservice records in its inventory the average system load information and the requested system property,
that it received from potentially multiple instances of the `system` service.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `InventoryResource` class.#
`inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java`
----

The [hotspot=updateSystemProperty file=0]`updateSystemProperty()` method creates the [hotspot=putPath file=0]`/data`
endpoint that accepts `PUT` requests with a system property name in the request body. When the `inventory` service receives
a request, it adds the system property name from the request body to the [hotspot=flowableEmitter file=0]`propertyNameEmitter`
[hotspot=flowableEmitterDecl file=0]`FlowableEmitter`. The [hotspot=flowableCreate file=0]`Flowable.create()` method from
RxJava is used to create a Publisher and an associated emitter. The property name sent to the emitter will be sent to the
Publisher. The Publisher is returned from the [hotspot=OutgoingPropertyName file=0]`@Outgoing("requestSystemProperty")`
channel, which is configured in the [hotspot file=1]`microprofile-config.properties`
[hotspot=requestSystemProperty file=1]`requestSystemProperty` stream and MicroProfile Reactive Messaging takes care of assigning the
Publisher to the channel.

== Creating the system microservice

//file 0
SystemService.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The `system` microservice is the producer of the messages that are published to the Kafka messaging system as a stream of
events. Every 15 seconds, the `system` microservice publishes events that contain its calculation of the average system
load (its CPU usage) for the last minute. It also processes the specific system property request from the `inventory`
microservice and publishes it to the Kafka messaging system.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `SystemService` class.#
`system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

The `system` microservice contains a method named [hotspot=sendProperty file=0]`sendProperty()` which receives a
system property name from the `inventory` microservice over the [hotspot=propertyRequest file=0]`@Incoming("propertyRequest")`
channel, calculates the requested property on the fly and publishes it back to Kafka over the
[hotspot=propertyResponse file=0]`@Outgoing("propertyResponse")` channel. The [hotspot=sendProperty file=0]`sendProperty()`
method acts as a processor in this scenario.

== Building and running the application

Build the `system` and `inventory` microservices using Maven and then run them in Docker containers.

Start your Docker environment. Dockerfiles are provided for you to use.

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
```

Next, use the provided script to start the application in Docker containers. The script creates a network for the
containers to communicate with each other. It also creates containers for Kafka, Zookeeper, and the microservices in the
project. For simplicity, the script starts one instance of the `system` service.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

== Testing the application

Wait for the services to become available. After the services are up and running, you can access the
application by making a GET request to the `/systems` endpoint of the `inventory` service.

Visit the http://localhost:9085/inventory/systems[^] URL to access the inventory microservice. You see the CPU `systemLoad`
property for all the systems:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",   
   "systemLoad":1.44
}
----

You can revisit the http://localhost:9085/inventory/systems[^] URL after a while, and you will notice the CPU `systemLoad`
property for the systems changed.

Make a `PUT` request on the `\http://localhost:9085/inventory/data` URL to add the value of a particular system
property to the set of existing properties.

For example :

The `PUT` request with the `os.name` system property in the request body on the `\http://localhost:9085/inventory/data`
URL will add the `os.name` system property for your system.

Make a `PUT` request to the service by using `curl`:

[role=command]
```
curl -X PUT -d "os.name" http://localhost:9085/inventory/data --header "Content-Type:text/plain"
```

If the `curl` command is unavailable, then use https://www.getpostman.com/[Postman^]. Postman enables you
to make requests using a graphical interface. To make a request with Postman, enter `\http://localhost:9085/inventory/systems`
into the URL bar and change the request from `GET` to `PUT`. Go to the `Body` tab and enter the `os.name` value under
raw category. Click the blue `Send` button to make the request.

You see the following output:

[source, role="no_copy"]
----
Request successful for the os.name property
----

Since the `system` service is available, the request to the service is successful and returns a `200` response code.

You can revisit the http://localhost:9085/inventory/systems[^] URL and see the `os.name` system property value in addition
to the previous values:

[source, role='no_copy']
----
{
   "hostname":"30bec2b63a96",
   "os.name":"Linux",
   "systemLoad":1.44
}
----

== Tearing down the environment

Run the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You just developed a reactive Java application using MicroProfile Reactive Messaging, Open Liberty, and Kafka.

include::{common-includes}/attribution.adoc[subs="attributes"]